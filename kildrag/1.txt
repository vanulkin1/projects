import telebot
from telebot import types
import sqlite3
import time
import asyncio
import random
import phonenumbers
import aiohttp
import smtplib
from email.mime.text import MIMEText
import os

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "8476985745:AAHI050sxV7mDEjxYWKrdUYZUqC_0qF6W4I"
CHANNEL_ID = -1002530726106
CHANNEL_LINK = "https://t.me/+XFo1yTBtmjcyYTRi"
ADMIN_IDS = [7163004463, 7465411120]
DATABASE_NAME = "spambot.db"
MAIL_FILE = "mails.txt"
BOT_USERNAME = "tg_spamerbot"
REFERRAL_REWARD = 0.05
MIN_WITHDRAWAL = 1

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
bot = telebot.TeleBot(TOKEN)
conn = sqlite3.connect(DATABASE_NAME, check_same_thread=False)
cursor = conn.cursor()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
captcha_answers = {}
mailer_data = {}

class Database:
    @staticmethod
    def create_tables():
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                reg_date INTEGER,
                is_admin INTEGER DEFAULT 0,
                banned INTEGER DEFAULT 0,
                has_subscription INTEGER DEFAULT 0,
                referral_balance REAL DEFAULT 0.0,
                referrer_id INTEGER
            )
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS referrals (
                referrer_id INTEGER,
                referral_id INTEGER,
                FOREIGN KEY (referrer_id) REFERENCES users(id),
                FOREIGN KEY (referral_id) REFERENCES users(id)
            )
        """)
        conn.commit()
    
    @staticmethod
    def add_user(user_id, username, referrer_id=None):
        cursor.execute("""
            INSERT OR IGNORE INTO users (id, username, reg_date, referrer_id) 
            VALUES (?, ?, ?, ?)
        """, (user_id, username, int(time.time()), referrer_id))
        conn.commit()
    
    @staticmethod
    def get_user(user_id):
        cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
        return cursor.fetchone()
    
    @staticmethod
    def is_user_banned(user_id):
        user = Database.get_user(user_id)
        return user[4] == 1 if user else False
    
    @staticmethod
    def ban_user(username):
        cursor.execute("UPDATE users SET banned = 1 WHERE username = ?", (username,))
        conn.commit()
    
    @staticmethod
    def unban_user(username):
        cursor.execute("UPDATE users SET banned = 0 WHERE username = ?", (username,))
        conn.commit()
    
    @staticmethod
    def get_all_users():
        cursor.execute("SELECT * FROM users")
        return cursor.fetchall()
    
    @staticmethod
    def check_subscription(user_id):
        user = Database.get_user(user_id)
        return user[5] == 1 if user else False
    
    @staticmethod
    def set_subscription(username, has_subscription):
        cursor.execute("""
            UPDATE users SET has_subscription = ? WHERE username = ?
        """, (int(has_subscription), username))
        conn.commit()
    
    @staticmethod
    def increase_referral_balance(user_id, amount):
        cursor.execute("""
            UPDATE users SET referral_balance = referral_balance + ? WHERE id = ?
        """, (amount, user_id))
        conn.commit()
    
    @staticmethod
    def get_referral_balance(user_id):
        user = Database.get_user(user_id)
        return user[6] if user else 0.0
    
    @staticmethod
    def add_referral(referrer_id, referral_id):
        cursor.execute("""
            INSERT INTO referrals (referrer_id, referral_id) VALUES (?, ?)
        """, (referrer_id, referral_id))
        conn.commit()
    
    @staticmethod
    def get_referrals(user_id):
        cursor.execute("SELECT referral_id FROM referrals WHERE referrer_id = ?", (user_id,))
        return [row[0] for row in cursor.fetchall()]
    
    @staticmethod
    def already_referred(referrer_id, user_id):
        cursor.execute("""
            SELECT * FROM referrals WHERE referrer_id = ? AND referral_id = ?
        """, (referrer_id, user_id))
        return cursor.fetchone() is not None

class Keyboards:
    @staticmethod
    def main_menu():
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("Telegram Spam üòà", callback_data="telegram_spam"))
        markup.add(types.InlineKeyboardButton("SMS Spam üò°", callback_data="sms_spam"))
        markup.add(types.InlineKeyboardButton("Mailer üìß", callback_data="mailer"))
        markup.add(types.InlineKeyboardButton("–ü—Ä–æ—Ñ–∏–ª—å üë§", callback_data="profile"))
        markup.add(types.InlineKeyboardButton("–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ üí∞", callback_data="referral_system"))
        return markup
    
    @staticmethod
    def back_button():
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥ üîô", callback_data="back_to_menu"))
        return markup
    
    @staticmethod
    def referral():
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("–í—ã–≤–µ—Å—Ç–∏", callback_data="withdraw"))
        markup.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥ üîô", callback_data="back_to_menu"))
        return markup
    
    @staticmethod
    def subscribe():
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("–ö–ê–ù–ê–õ üî•", url=CHANNEL_LINK))
        return markup
    
    @staticmethod
    def russian_captcha(correct_answer):
        markup = types.InlineKeyboardMarkup()
        answers = [correct_answer]
        while len(answers) < 4:
            incorrect = str(random.randint(int(correct_answer)-5, int(correct_answer)+5))
            if incorrect not in answers:
                answers.append(incorrect)
        random.shuffle(answers)
        for answer in answers:
            markup.add(types.InlineKeyboardButton(text=answer, callback_data=f"captcha_{answer}"))
        return markup

class Utils:
    @staticmethod
    def generate_russian_captcha():
        num1 = random.randint(1, 20)
        num2 = random.randint(1, 20)
        operation = random.choice(['+', '-'])
        
        if operation == '+':
            answer = num1 + num2
            question = f"–°–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç {num1} + {num2}?"
        else:
            answer = num1 - num2
            question = f"–°–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç {num1} - {num2}?"
        
        return question, str(answer)
    
    @staticmethod
    def check_subscription_channel(user_id):
        try:
            chat_member = bot.get_chat_member(CHANNEL_ID, user_id)
            return chat_member.status in ['member', 'administrator', 'creator']
        except Exception as e:
            print(f"Error checking subscription: {e}")
            return False
    
    @staticmethod
    async def send_request(url, phone, session):
        try:
            headers = {
                'User-Agent': random.choice(spam.user_agents),
                'Content-Type': 'application/x-www-form-urlencoded',
            }
            
            async with session.post(
                url, 
                headers=headers, 
                data=f'phone={phone}', 
                ssl=False,
                timeout=10
            ) as response:
                if response.status == 200:
                    return {
                        'success': True,
                        'status': response.status,
                        'url': url,
                        'hostname': url.split('//')[-1].split('/')[0] if '//' in url else url.split('/')[0],
                        'user_agent': headers['User-Agent'],
                    }
                return {
                    'error': f'Status {response.status}',
                    'hostname': url.split('//')[-1].split('/')[0] if '//' in url else url.split('/')[0],
                    'user_agent': headers['User-Agent'],
                }
        except Exception as e:
            return {
                'error': str(e),
                'hostname': url.split('//')[-1].split('/')[0] if '//' in url else url.split('/')[0],
                'user_agent': headers.get('User-Agent', 'Unknown'),
            }
    
    @staticmethod
    async def start_attack(phone, chat_id, message_id):
        try:
            parsed = phonenumbers.parse(phone, None)
            if not phonenumbers.is_valid_number(parsed):
                bot.send_message(chat_id, "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞! ‚ùå")
                return
        except phonenumbers.NumberParseException:
            bot.send_message(chat_id, "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞! ‚ùå")
            return

        success = error = warning = 0

        async with aiohttp.ClientSession() as session:
            tasks = [Utils.send_request(url, phone, session) for url in spam.URLs]
            results = await asyncio.gather(*tasks)

            for result in results:
                if 'error' in result:
                    error += 1
                elif result.get('success'):
                    success += 1
                else:
                    warning += 1

        bot.send_message(
            chat_id,
            f"–ê—Ç–∞–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n–£—Å–ø–µ—à–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤: {success} ‚úÖ\n–û—à–∏–±–æ–∫: {error} ‚ö†Ô∏è\n–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π: {warning} ‚ùó"
        )

    @staticmethod
    def send_emails(user_id):
        try:
            data = mailer_data.get(user_id, {})
            if not data:
                bot.send_message(user_id, "–î–∞–Ω–Ω—ã–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                return

            count = data['count']
            to_email = data['email_address']
            subject = data['subject']
            content = data['content']

            if not os.path.exists(MAIL_FILE):
                bot.send_message(user_id, "–§–∞–π–ª —Å –ø–æ—á—Ç–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                return

            with open(MAIL_FILE, "r") as f:
                mail_data = [line.strip().split(":") for line in f if ":" in line]

            sent = 0
            for _ in range(min(count, len(mail_data))):
                from_email, password = random.choice(mail_data)
                msg = MIMEText(content)
                msg['Subject'] = subject
                msg['From'] = from_email
                msg['To'] = to_email

                try:
                    with smtplib.SMTP('smtp.firstmail.ru', 587) as server:
                        server.starttls()
                        server.login(from_email, password)
                        server.sendmail(from_email, to_email, msg.as_string())
                    sent += 1
                except Exception as e:
                    print(f"Error sending email: {e}")

            bot.send_message(
                user_id, 
                f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {sent} –ø–∏—Å–µ–º.",
                reply_markup=Keyboards.back_button()
            )
        except Exception as e:
            bot.send_message(user_id, f"–û—à–∏–±–∫–∞: {str(e)}")
        finally:
            mailer_data.pop(user_id, None)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@bot.message_handler(commands=['start'])
def start(message):
    user_id = message.from_user.id
    username = message.from_user.username
    referrer_id = None

    if len(message.text.split()) > 1:
        try:
            referrer_id = int(message.text.split()[1])
        except ValueError:
            pass

    if not Database.get_user(user_id):
        Database.add_user(user_id, username, referrer_id)

    if Database.is_user_banned(user_id):
        bot.send_message(user_id, "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã. ü§°")
        return

    if not Database.check_subscription(user_id):
        question, answer = Utils.generate_russian_captcha()
        msg = bot.send_message(
            user_id, 
            question, 
            reply_markup=Keyboards.russian_captcha(answer)
        )
        captcha_answers[msg.message_id] = answer
    else:
        bot.send_message(
            user_id, 
            "Hello, World! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!", 
            reply_markup=Keyboards.main_menu()
        )

@bot.message_handler(commands=['admin'])
def admin_panel(message):
    if message.from_user.id not in ADMIN_IDS:
        bot.send_message(message.chat.id, "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
        return

    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    markup.add(
        types.KeyboardButton("–ü—Ä–æ—Å–º–æ—Ç—Ä –ë–î üìä"),
        types.KeyboardButton("–ó–∞–±–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è üö´"),
        types.KeyboardButton("–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è üì¢"),
        types.KeyboardButton("–ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ‚úÖ"),
        types.KeyboardButton("–ó–∞–±—Ä–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É ‚ùå")
    )
    bot.send_message(message.chat.id, "–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å üõ°Ô∏è", reply_markup=markup)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
@bot.message_handler(func=lambda m: m.text == "–ü—Ä–æ—Å–º–æ—Ç—Ä –ë–î üìä" and m.from_user.id in ADMIN_IDS)
def view_db(message):
    users = Database.get_all_users()
    with open("users.txt", "w", encoding="utf-8") as f:
        for user in users:
            f.write(
                f"ID: {user[0]}, Username: @{user[1]}, "
                f"–î–∞—Ç–∞: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(user[2]))}, "
                f"–ê–¥–º–∏–Ω: {user[3]}, –ë–∞–Ω: {user[4]}, –ü–æ–¥–ø–∏—Å–∫–∞: {user[5]}, "
                f"–ë–∞–ª–∞–Ω—Å: {user[6]}, –†–µ—Ñ–µ—Ä–µ—Ä: {user[7]}\n"
            )
    with open("users.txt", "rb") as f:
        bot.send_document(message.chat.id, f)
    os.remove("users.txt")

@bot.message_handler(func=lambda m: m.text.startswith("–ó–∞–±–∞–Ω–∏—Ç—å") and m.from_user.id in ADMIN_IDS)
def ban_user_handler(message):
    bot.send_message(message.chat.id, "–í–≤–µ–¥–∏—Ç–µ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –±–∞–Ω–∞:")
    bot.register_next_step_handler(message, process_ban)

def process_ban(message):
    username = message.text.replace("@", "").strip()
    Database.ban_user(username)
    bot.send_message(message.chat.id, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{username} –∑–∞–±–∞–Ω–µ–Ω.")

# –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è –¥—Ä—É–≥–∏—Ö –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∫–æ–º–∞–Ω–¥...

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ callback-–∑–∞–ø—Ä–æ—Å–æ–≤
@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    user_id = call.from_user.id
    user = Database.get_user(user_id)

    if Database.is_user_banned(user_id):
        bot.answer_callback_query(call.id, "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
        return

    if call.data.startswith("captcha_"):
        handle_captcha(call)
    elif call.data == "telegram_spam":
        handle_telegram_spam(call)
    elif call.data == "sms_spam":
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="Coming soon üõ†Ô∏è",
            reply_markup=Keyboards.back_button()
        )
    elif call.data == "mailer":
        handle_mailer(call)
    elif call.data == "profile":
        show_profile(call)
    elif call.data == "referral_system":
        show_referral(call)
    elif call.data == "withdraw":
        handle_withdraw(call)
    elif call.data == "back_to_menu":
        handle_back(call)
    
    bot.answer_callback_query(call.id)

def handle_captcha(call):
    selected = call.data.split("_")[1]
    correct = captcha_answers.get(call.message.message_id)
    
    if selected == correct:
        captcha_answers.pop(call.message.message_id, None)
        if Utils.check_subscription_channel(call.from_user.id):
            Database.set_subscription(call.from_user.username, True)
            bot.edit_message_text(
                chat_id=call.message.chat.id,
                message_id=call.message.message_id,
                text="Hello, World! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!",
                reply_markup=Keyboards.main_menu()
            )
            handle_referral(call.from_user.id)
        else:
            bot.edit_message_text(
                chat_id=call.message.chat.id,
                message_id=call.message.message_id,
                text="–î–ª—è –¥–æ—Å—Ç—É–ø–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª üöÄ",
                reply_markup=Keyboards.subscribe()
            )
    else:
        question, answer = Utils.generate_russian_captcha()
        captcha_answers[call.message.message_id] = answer
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=question,
            reply_markup=Keyboards.russian_captcha(answer)
        )

def handle_referral(user_id):
    user = Database.get_user(user_id)
    if user and user[7] and not Database.already_referred(user[7], user_id):
        Database.increase_referral_balance(user[7], REFERRAL_REWARD)
        Database.add_referral(user[7], user_id)
        new_balance = Database.get_referral_balance(user[7])
        bot.send_message(
            user[7], 
            f"–£ –≤–∞—Å –Ω–æ–≤—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª! –ë–∞–ª–∞–Ω—Å: {new_balance:.2f}$"
        )

# –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏...

if __name__ == '__main__':
    try:
        import spam
        Database.create_tables()
        bot.infinity_polling()
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: {e}")




–¥–æ–ø–∏—à–∏ –¥–∞–Ω–Ω—ã–π –∫–æ–¥, —Å–¥–µ–ª–∞—è –µ–≥–æ –ø–æ—Ö–æ–∂–∏–º –Ω–∞ —Ç–≤–æ–π (–ø–æ –ª–æ–≥–∏–∫–µ —Ä–∞–±–æ—Ç—ã)
# –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏... - —ç—Ç–æ –Ω–∞–¥–æ —É–±—Ä–∞—Ç—å –∏ 